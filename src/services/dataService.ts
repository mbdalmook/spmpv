/**
 * Data Service — Generic CRUD operations against Supabase.
 *
 * Handles camelCase ↔ snake_case conversion automatically.
 * Returns { data, error } pattern for consistent error handling.
 */

import { supabase } from '../lib/supabase';
import { toCamelCase, toSnakeCase } from '../utils/caseMapper';

// --- Service result type ---

export interface ServiceResult<T> {
  data: T | null;
  error: string | null;
}

// Fields auto-generated by the database — strip before inserts/updates
const DB_GENERATED_FIELDS = ['id', 'uid', 'createdAt', 'updatedAt', 'isSingleton'];

function stripGenerated(obj: Record<string, unknown>): Record<string, unknown> {
  const result = { ...obj };
  for (const key of DB_GENERATED_FIELDS) {
    delete result[key];
  }
  return result;
}

/**
 * Extract a user-friendly error message from Supabase errors.
 */
function friendlyError(err: { code?: string; message?: string; details?: string }): string {
  if (err.code === '23505') return 'A record with that value already exists (duplicate)';
  if (err.code === '23503') return 'Cannot delete — this record is referenced by other data';
  return err.message ?? 'Unknown database error';
}

// --- Generic CRUD ---

export const dataService = {
  /**
   * Get all rows from a table.
   */
  async getAll<T>(table: string): Promise<ServiceResult<T[]>> {
    const { data, error } = await supabase.from(table).select('*');
    if (error) return { data: null, error: friendlyError(error) };
    const mapped = (data as Record<string, unknown>[]).map((row) => toCamelCase<T>(row));
    return { data: mapped, error: null };
  },

  /**
   * Get a single row by ID.
   */
  async getById<T>(table: string, id: string): Promise<ServiceResult<T>> {
    const { data, error } = await supabase.from(table).select('*').eq('id', id).single();
    if (error) return { data: null, error: friendlyError(error) };
    return { data: toCamelCase<T>(data as Record<string, unknown>), error: null };
  },

  /**
   * Insert a new row.
   */
  async create<T>(table: string, payload: Partial<T>): Promise<ServiceResult<T>> {
    const snakePayload = toSnakeCase(stripGenerated(payload as Record<string, unknown>));
    const { data, error } = await supabase.from(table).insert(snakePayload).select().single();
    if (error) return { data: null, error: friendlyError(error) };
    return { data: toCamelCase<T>(data as Record<string, unknown>), error: null };
  },

  /**
   * Update an existing row by ID.
   */
  async update<T>(table: string, id: string, payload: Partial<T>): Promise<ServiceResult<T>> {
    const snakePayload = toSnakeCase(stripGenerated(payload as Record<string, unknown>));
    const { data, error } = await supabase
      .from(table)
      .update(snakePayload)
      .eq('id', id)
      .select()
      .single();
    if (error) return { data: null, error: friendlyError(error) };
    return { data: toCamelCase<T>(data as Record<string, unknown>), error: null };
  },

  /**
   * Delete a row by ID.
   */
  async remove(table: string, id: string): Promise<ServiceResult<null>> {
    const { error } = await supabase.from(table).delete().eq('id', id);
    if (error) return { data: null, error: friendlyError(error) };
    return { data: null, error: null };
  },

  /**
   * Get a singleton row (company_profile or app_settings).
   * Returns null data (not an error) if the table is empty.
   */
  async getSingleton<T>(table: string): Promise<ServiceResult<T>> {
    const { data, error } = await supabase.from(table).select('*').limit(1).maybeSingle();
    if (error) return { data: null, error: friendlyError(error) };
    if (!data) return { data: null, error: null };
    return { data: toCamelCase<T>(data as Record<string, unknown>), error: null };
  },

  /**
   * Upsert a singleton row.
   * If a row exists: update it. If not: insert one.
   */
  async upsertSingleton<T>(table: string, payload: Partial<T>): Promise<ServiceResult<T>> {
    // Check if a row already exists
    const { data: existing } = await supabase.from(table).select('id').limit(1).maybeSingle();

    const snakePayload = toSnakeCase(stripGenerated(payload as Record<string, unknown>));

    if (existing) {
      // Update the existing singleton row
      const { data, error } = await supabase
        .from(table)
        .update(snakePayload)
        .eq('id', existing.id)
        .select()
        .single();
      if (error) return { data: null, error: friendlyError(error) };
      return { data: toCamelCase<T>(data as Record<string, unknown>), error: null };
    } else {
      // Insert a new singleton row (add is_singleton flag)
      const insertPayload = { ...snakePayload, is_singleton: true };
      const { data, error } = await supabase
        .from(table)
        .insert(insertPayload)
        .select()
        .single();
      if (error) return { data: null, error: friendlyError(error) };
      return { data: toCamelCase<T>(data as Record<string, unknown>), error: null };
    }
  },
};
